package cache

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"sort"
	"strings"

	"github.com/cszatmary/shed/errors"
	"github.com/cszatmary/shed/tool"
	"golang.org/x/mod/modfile"
	"golang.org/x/mod/module"
	"golang.org/x/mod/semver"
)

// goVersion holds the version of Go that the user has installed.
// This is lazily computed and cached. Do not use this variable directly,
// instead use GoVersion().
var goVersion string

// modfileName is the name of the go mod file used.
const modfileName = "go.mod"

// createGoModFile creates and writes an empty go.mod file at the path referenced by dir.
// mod is used as the module name. This functions similar to 'go mod init'.
func createGoModFile(ctx context.Context, op errors.Op, mod, dir string) error {
	modFile := &modfile.File{}
	modFile.AddComment("// Autogenerated by https://github.com/cszatmary/shed. DO NOT EDIT")
	if err := modFile.AddModuleStmt(mod); err != nil {
		return errors.New(errors.Go, "failed to add module statement to modfile", op, err)
	}

	version, err := GoVersion(ctx)
	if err != nil {
		return err
	}
	if err := modFile.AddGoStmt(version); err != nil {
		return errors.New(errors.Go, "failed to add go statement to modfile", op, err)
	}

	modfilePath := filepath.Join(dir, modfileName)
	return writeGoModFile(op, modFile, modfilePath)
}

// writeGoModFile formats and writes modFile to modfilePath.
func writeGoModFile(op errors.Op, modFile *modfile.File, modfilePath string) error {
	data, err := modFile.Format()
	if err != nil {
		return errors.New(errors.Go, fmt.Sprintf("failed to format modfile %s", modfilePath), op, err)
	}
	if err := os.WriteFile(modfilePath, data, 0o644); err != nil {
		return errors.New(errors.IO, fmt.Sprintf("failed to write modfile to %s", modfilePath), op, err)
	}
	return nil
}

// readGoModFile reads the go.mod file at path modfilePath.
//
// kind is used to categorize errors that occur while parsing the modfile.
//
// If no modfile exists at modfilePath, both return values will be nil. If the returned error
// is non-nil, then returned modfile will be nil.
func readGoModFile(op errors.Op, kind errors.Kind, modfilePath string) (*modfile.File, error) {
	data, err := os.ReadFile(modfilePath)
	if os.IsNotExist(err) {
		return nil, nil
	}
	if err != nil {
		return nil, errors.New(errors.IO, fmt.Sprintf("failed to read modfile %s", modfilePath), op, err)
	}
	modFile, err := modfile.Parse(modfilePath, data, nil)
	if err != nil {
		return nil, errors.New(kind, fmt.Sprintf("failed to parse modfile %s", modfilePath), op, err)
	}
	return modFile, nil
}

// readGoModFile reads the go.mod file at path modfilePath. It also validates the modfile to ensure
// it only has 1 dependency and that the dependency is for the tool t.
//
// kind is used to categorize errors that occur while parsing or validating the modfile.
//
// If no modfile exists at modfilePath, both return values will be nil. If the returned error
// is non-nil, the returned modfile will be nil.

// getModule finds the module that provides tool t from the modfile.
func getModule(op errors.Op, kind errors.Kind, modFile *modfile.File, t tool.Tool) (module.Version, error) {
	// Validation checks
	// There should only be a single direct require, otherwise something is wrong
	var directRequires []*modfile.Require
	for _, r := range modFile.Require {
		if !r.Indirect {
			directRequires = append(directRequires, r)
		}
	}
	if len(directRequires) != 1 {
		msg := fmt.Sprintf("expected 1 direct require statement in modfile but found %d", len(directRequires))
		return module.Version{}, errors.New(kind, msg, op)
	}
	mod := directRequires[0].Mod
	// Check prefix since actual module could have less then what we are installing
	// Ex: golang.org/x/tools vs golang.org/x/tools/cmd/stringer
	if !strings.HasPrefix(t.ImportPath, mod.Path) {
		return mod, errors.New(kind, fmt.Sprintf("incorrect dependency in modfile, found %s", mod.Path), op)
	}
	return mod, nil
}

// GoVersion finds the version of Go that is installed.
func GoVersion(ctx context.Context) (string, error) {
	const op = errors.Op("cache.GoVersion")
	if goVersion != "" {
		return goVersion, nil
	}
	var stdout bytes.Buffer
	if err := execGo(ctx, op, &stdout, "", "version"); err != nil {
		return "", err
	}
	re := regexp.MustCompile(`go?((?:[1-9][0-9]*)\.(?:0|[1-9][0-9]*))`)
	matches := re.FindSubmatch(stdout.Bytes())
	if len(matches) != 2 {
		return "", errors.New(
			errors.Go,
			fmt.Sprintf("unexpected go version format %s, unable to parse", stdout.String()),
			op,
		)
	}
	goVersion = string(matches[1])
	return goVersion, nil
}

// Go represents the core functionality provided by the go command.
// It allows for downloading and building of modules.
type Go interface {
	// Build builds pkg and outputs the binary at outPath. dir is used as the working directory
	// when building. pkg must be a valid import path.
	// Build functions like 'go build -o'.
	//
	// The provided context is used to terminate the build if the context becomes
	// done before the build completes on its own.
	Build(ctx context.Context, pkg, outPath, dir string) error
	// GetD downloads the source code for the module mod. dir is used as the working directory
	// and is expected to contain a go.mod file which will be updated with the installed module.
	// mod must be a valid module name, that is an import path, optionally with a version.
	// If no version is provided, the latest version will be downloaded.
	// GetD functions like 'got get -d' in module aware mode.
	//
	// The provided context is used to terminate the download if the context becomes
	// done before the download completes on its own.
	GetD(ctx context.Context, mod, dir string) error
	// ListU lists the details of mod and a version update if one is available. dir is used as
	// the working directory and is expected to contain a go.mod file with mod.
	// ListU functions like 'go list -m -u -json'.
	//
	// The provided context is used to terminate listing if the context becomes done
	// before listing completes on its own.
	ListU(ctx context.Context, mod, dir string) (GoModule, error)
}

type GoModule struct {
	Path    string    // module path
	Version string    // module version
	Update  *GoModule // available update, if any (with -u)
}

// realGo is the main implementation of the Go interface.
// It is a wrapper around the go command.
type realGo struct{}

// NewGo returns a new Go instance which allows for downloading and building modules.
func NewGo() Go {
	return realGo{}
}

func (realGo) Build(ctx context.Context, pkg, outPath, dir string) error {
	return execGo(ctx, errors.Op("Go.Build"), nil, dir, "build", "-o", outPath, pkg)
}

func (realGo) GetD(ctx context.Context, mod, dir string) error {
	return execGo(ctx, errors.Op("Go.GetD"), nil, dir, "get", "-d", mod)
}

func (realGo) ListU(ctx context.Context, mod, dir string) (GoModule, error) {
	const op = errors.Op("Go.ListU")
	var gm GoModule
	var stdout bytes.Buffer
	err := execGo(ctx, op, &stdout, dir, "list", "-u", "-m", "-json", mod)
	if err != nil {
		return gm, err
	}
	if err := json.NewDecoder(&stdout).Decode(&gm); err != nil {
		return gm, errors.New(errors.Internal, "failed to unmarshal go list output json", op, err)
	}
	return gm, nil
}

func execGo(ctx context.Context, op errors.Op, stdout io.Writer, dir string, args ...string) error {
	cmd := exec.CommandContext(ctx, "go", args...)
	cmd.Dir = dir
	cmd.Stdout = stdout
	var stderr bytes.Buffer
	cmd.Stderr = &stderr
	if err := cmd.Run(); err != nil {
		msg := fmt.Sprintf("failed to run 'go %s', stderr: %s", strings.Join(args, " "), stderr.String())
		return errors.New(errors.Go, msg, op, err)
	}
	return nil
}

// mockGo provides a implementation of the Go interface that is suitable for testing.
type mockGo struct {
	// Tool import path to module
	registry map[string]mockModule
}

type mockModule struct {
	// Name of the module, i.e. the import path
	name string
	// List of semver versions, must be sorted from earliest to latest version
	versions []string
	// Queries to versions
	queries map[string]string
}

// NewMockGo returns a new Go instance that is suitable for testing.
// Tools is a map of import paths to a map of queries to versions.
func NewMockGo(tools map[string]map[string]string) (Go, error) {
	registry := make(map[string]mockModule)
	for tn, queries := range tools {
		t, err := tool.ParseLax(tn)
		if err != nil {
			return nil, err
		}

		// Take first 3 parts as the module name
		// This should be good enough for testing purposes
		modName := strings.Join(strings.Split(t.ImportPath, "/")[:3], "/")
		m := mockModule{name: modName, queries: queries}
		var versions []string
		for q := range queries {
			if semver.IsValid(q) && q == semver.Canonical(q) {
				versions = append(versions, q)
			}
		}
		m.versions = versions
		registry[t.ImportPath] = m
	}

	for _, m := range registry {
		// Sort versions so we can easily find the latest version
		sort.Slice(m.versions, func(i, j int) bool {
			return semver.Compare(m.versions[i], m.versions[j]) == -1
		})
	}
	return &mockGo{registry: registry}, nil
}

func (mg *mockGo) Build(ctx context.Context, pkg, outPath, dir string) error {
	const op = "mockGo.Build"
	if _, ok := mg.registry[pkg]; !ok {
		return errors.New(errors.Invalid, fmt.Sprintf("unknown package %s", pkg), op)
	}
	// Can just write an empty file to outPath so the binary "exists"
	if err := os.WriteFile(outPath, nil, 0o644); err != nil {
		return errors.New(errors.IO, fmt.Sprintf("failed to write build to %s", outPath), op, err)
	}
	return nil
}

func (mg *mockGo) GetD(ctx context.Context, mod, dir string) error {
	const op = "mockGo.GetD"
	t, err := tool.ParseLax(mod)
	if err != nil {
		return err
	}
	m, ok := mg.registry[t.ImportPath]
	if !ok {
		return errors.New(errors.Invalid, fmt.Sprintf("unknown package %s", mod), op)
	}

	modver := module.Version{Path: m.name}
	if t.Version == "" || t.Version == "latest" {
		modver.Version = m.versions[len(m.versions)-1]
	} else {
		// If version is provided, see if it exists
		found := false
		// TODO(@cszatmary): Make this work with shorthand semvers
		if t.HasSemver() {
			for _, v := range m.versions {
				if v == t.Version {
					modver.Version = v
					found = true
					break
				}
			}
		} else {
			// If no semver, see if a matching query exists
			for q, v := range m.queries {
				if q == t.Version {
					modver.Version = v
					found = true
					break
				}
			}
		}
		if !found {
			return errors.New(errors.Invalid, fmt.Sprintf("module %s has no version %s", t.ImportPath, t.Version), op)
		}
	}

	modfilePath := filepath.Join(dir, modfileName)
	modFile, err := readGoModFile(op, errors.Internal, modfilePath)
	if err != nil {
		return err
	}
	if modFile == nil {
		// Treat no go.mod as an error because it is required for shed to work properly.
		// If there is no go.mod then go get will function in non-module mode which we don't want.
		return errors.New(errors.Internal, fmt.Sprintf("failed to download %s, no go.mod file found at %s", mod, dir), op)
	}

	// Add resolved module to go.mod
	modFile.AddNewRequire(modver.Path, modver.Version, true)
	if err := writeGoModFile(op, modFile, modfilePath); err != nil {
		return err
	}
	return nil
}

func (mg mockGo) ListU(ctx context.Context, mod, dir string) (GoModule, error) {
	const op = "mockGo.ListU"
	var gm GoModule
	modfilePath := filepath.Join(dir, modfileName)
	modFile, err := readGoModFile(op, errors.Internal, modfilePath)
	if err != nil {
		return gm, err
	}
	if modFile == nil {
		// Treat no go.mod as an error because it is required for shed to work properly.
		return gm, errors.New(errors.Internal, fmt.Sprintf("no go.mod file found at %s", dir), op)
	}

	var r *modfile.Require
	found := false
	for _, rr := range modFile.Require {
		if rr.Mod.Path == mod {
			r = rr
			found = true
		}
	}
	if !found {
		return gm, errors.New(errors.Invalid, fmt.Sprintf("module %s is not a known dependency", mod), op)
	}

	// Find the matching module, can't do fast lookup since we don't have the tool import path
	var latest string
	found = false
	for _, m := range mg.registry {
		if m.name == r.Mod.Path {
			latest = m.versions[len(m.versions)-1]
			found = true
			break
		}
	}
	if !found {
		return gm, errors.New(errors.Invalid, fmt.Sprintf("unknown module %s", r.Mod.Path), op)
	}

	gm.Path = r.Mod.Path
	gm.Version = r.Mod.Version
	if latest != r.Mod.Version {
		gm.Update = &GoModule{Path: r.Mod.Path, Version: latest}
	}
	return gm, nil
}
