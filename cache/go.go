package cache

import (
	"bytes"
	"go/build"
	"io/ioutil"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/pkg/errors"
	"golang.org/x/mod/modfile"
)

// createGoModFile creates and writes an empty go.mod file at the path referenced by dir.
// mod is used as the module name. This functions similar to 'go mod init'.
func createGoModFile(mod, dir string) error {
	modFile := &modfile.File{}
	modFile.AddComment("// Autogenerated by https://github.com/getshiphub/shed. DO NOT EDIT")
	modFile.AddModuleStmt(mod)

	// Add go statement
	tags := build.Default.ReleaseTags
	version := tags[len(tags)-1]
	if !strings.HasPrefix(version, "go") || !modfile.GoVersionRE.MatchString(version[2:]) {
		return errors.Errorf("unrecognized default go version %q", version)
	}
	if err := modFile.AddGoStmt(version[2:]); err != nil {
		return errors.Wrap(err, "failed to add go statement to modfile")
	}

	data, err := modFile.Format()
	if err != nil {
		return errors.Wrapf(err, "failed to create modfile")
	}
	modFilePath := filepath.Join(dir, "go.mod")
	err = ioutil.WriteFile(modFilePath, data, 0o644)
	if err != nil {
		return errors.Wrapf(err, "failed to write modfile %s", modFilePath)
	}
	return nil
}

// Go represents the core functionality provided by the go command. It allows for downloading
// and building of modules.
type Go interface {
	// Build builds pkg and outputs the binary at outPath. dir is used as the working directory
	// when building. pkg must be a valid import path.
	// Build functions like 'go build -o'.
	Build(pkg, outPath, dir string) error
	// GetD downloads the source code for the module mod. dir is used as the working directory
	// and is expected to contain a go.mod file which will be updated with the installed module.
	// mod must be a valid module name, that is an import path, optionally with a version.
	// If no version is provided, the latest version will be downloaded.
	// GetD functions like 'got get -d' in module aware mode.
	GetD(mod, dir string) error
}

// realGo is the main implementation of the Go interface.
// It is a wrapper around the go command.
type realGo struct{}

// NewGo returns a new Go instance which allows for downloading and building modules.
func NewGo() Go {
	return realGo{}
}

func (realGo) Build(pkg, outPath, dir string) error {
	return execGo(dir, "build", "-o", outPath, pkg)
}

func (realGo) GetD(mod, dir string) error {
	return execGo(dir, "get", "-d", mod)
}

func execGo(dir string, args ...string) error {
	cmd := exec.Command("go", args...)
	cmd.Dir = dir
	stderr := &bytes.Buffer{}
	cmd.Stderr = stderr

	err := cmd.Run()
	if err != nil {
		argsStr := strings.Join(args, " ")
		return errors.Wrapf(err, "failed to run 'go %s', stderr: %s", argsStr, stderr.String())
	}
	return nil
}

// mockGo provides a implementation of the Go interface that is suitable for testing.
type mockGo struct{}

// NewMockGo returns a new Go instance that is suitable for testing.
func NewMockGo() Go {
	return &mockGo{}
}

func (mg *mockGo) Build(pkg, outPath, dir string) error {
	panic("unimplemented")
}

func (mg *mockGo) GetD(mod, dir string) error {
	panic("unimplemented")
}
