package cache

import (
	"bytes"
	"context"
	"encoding/json"
	"go/build"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"

	"github.com/getshiphub/shed/internal/util"
	"github.com/getshiphub/shed/tool"
	"github.com/pkg/errors"
	"golang.org/x/mod/modfile"
	"golang.org/x/mod/module"
	"golang.org/x/mod/semver"
)

// createGoModFile creates and writes an empty go.mod file at the path referenced by dir.
// mod is used as the module name. This functions similar to 'go mod init'.
func createGoModFile(mod, dir string) error {
	modFile := &modfile.File{}
	modFile.AddComment("// Autogenerated by https://github.com/getshiphub/shed. DO NOT EDIT")
	// AddModuleStmt never actually returns an error, not sure why it's in the signature
	if err := modFile.AddModuleStmt(mod); err != nil {
		return errors.Wrap(err, "failed to add module statement to modfile")
	}

	// Add go statement
	tags := build.Default.ReleaseTags
	version := tags[len(tags)-1]
	if !strings.HasPrefix(version, "go") || !modfile.GoVersionRE.MatchString(version[2:]) {
		return errors.Errorf("unrecognized default go version %q", version)
	}
	if err := modFile.AddGoStmt(version[2:]); err != nil {
		return errors.Wrap(err, "failed to add go statement to modfile")
	}

	data, err := modFile.Format()
	if err != nil {
		return errors.Wrap(err, "failed to create modfile")
	}
	modfilePath := filepath.Join(dir, "go.mod")
	if err := os.WriteFile(modfilePath, data, 0o644); err != nil {
		return errors.Wrapf(err, "failed to write modfile %s", modfilePath)
	}
	return nil
}

// Go represents the core functionality provided by the go command.
// It allows for downloading and building of modules.
type Go interface {
	// Build builds pkg and outputs the binary at outPath. dir is used as the working directory
	// when building. pkg must be a valid import path.
	// Build functions like 'go build -o'.
	//
	// The provided context is used to terminate the build if the context becomes
	// done before the build completes on its own.
	Build(ctx context.Context, pkg, outPath, dir string) error
	// GetD downloads the source code for the module mod. dir is used as the working directory
	// and is expected to contain a go.mod file which will be updated with the installed module.
	// mod must be a valid module name, that is an import path, optionally with a version.
	// If no version is provided, the latest version will be downloaded.
	// GetD functions like 'got get -d' in module aware mode.
	//
	// The provided context is used to terminate the download if the context becomes
	// done before the download completes on its own.
	GetD(ctx context.Context, mod, dir string) error
	// ListU lists the details of mod and a version update if one is available. dir is used as
	// the working directory and is expected to contain a go.mod file with mod.
	// ListU functions like 'go list -m -u -json'.
	//
	// The provided context is used to terminate listing if the context becomes done
	// before listing completes on its own.
	ListU(ctx context.Context, mod, dir string) (GoModule, error)
}

type GoModule struct {
	Path    string    // module path
	Version string    // module version
	Update  *GoModule // available update, if any (with -u)
}

// realGo is the main implementation of the Go interface.
// It is a wrapper around the go command.
type realGo struct{}

// NewGo returns a new Go instance which allows for downloading and building modules.
func NewGo() Go {
	return realGo{}
}

func (realGo) Build(ctx context.Context, pkg, outPath, dir string) error {
	return execGo(ctx, dir, "build", "-o", outPath, pkg)
}

func (realGo) GetD(ctx context.Context, mod, dir string) error {
	return execGo(ctx, dir, "get", "-d", mod)
}

func (realGo) ListU(ctx context.Context, mod, dir string) (GoModule, error) {
	args := []string{"list", "-u", "-m", "-json", mod}
	cmd := exec.CommandContext(ctx, "go", args...)
	cmd.Dir = dir
	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr
	var gm GoModule
	if err := cmd.Run(); err != nil {
		argsStr := strings.Join(args, " ")
		return gm, errors.Wrapf(err, "failed to run 'go %s', stderr: %s", argsStr, stderr.String())
	}
	if err := json.NewDecoder(&stdout).Decode(&gm); err != nil {
		return gm, errors.Wrap(err, "failed to unmarshal go list output as json")
	}
	return gm, nil
}

func execGo(ctx context.Context, dir string, args ...string) error {
	cmd := exec.CommandContext(ctx, "go", args...)
	cmd.Dir = dir
	var stderr bytes.Buffer
	cmd.Stderr = &stderr
	if err := cmd.Run(); err != nil {
		argsStr := strings.Join(args, " ")
		return errors.Wrapf(err, "failed to run 'go %s', stderr: %s", argsStr, stderr.String())
	}
	return nil
}

// mockGo provides a implementation of the Go interface that is suitable for testing.
type mockGo struct {
	// Tool import path to module
	registry map[string]mockModule
}

type mockModule struct {
	// Name of the module, i.e. the import path
	name string
	// List of semver versions, must be sorted from earliest to latest version
	versions []string
	// Queries to versions
	queries map[string]string
}

// NewMockGo returns a new Go instance that is suitable for testing.
// Tools is a map of import paths to a map of queries to versions.
func NewMockGo(tools map[string]map[string]string) (Go, error) {
	registry := make(map[string]mockModule)
	for tn, queries := range tools {
		t, err := tool.ParseLax(tn)
		if err != nil {
			return nil, err
		}

		// Take first 3 parts as the module name
		// This should be good enough for testing purposes
		modName := strings.Join(strings.Split(t.ImportPath, "/")[:3], "/")
		m := mockModule{name: modName, queries: queries}
		var versions []string
		for q := range queries {
			if semver.IsValid(q) && q == semver.Canonical(q) {
				versions = append(versions, q)
			}
		}
		m.versions = versions
		registry[t.ImportPath] = m
	}

	for _, m := range registry {
		// Sort versions so we can easily find the latest version
		sort.Slice(m.versions, func(i, j int) bool {
			return semver.Compare(m.versions[i], m.versions[j]) == -1
		})
	}
	return &mockGo{registry: registry}, nil
}

func (mg *mockGo) Build(ctx context.Context, pkg, outPath, dir string) error {
	if _, ok := mg.registry[pkg]; !ok {
		return errors.Errorf("unknown package %s", pkg)
	}
	if !util.FileOrDirExists(dir) {
		return errors.Errorf("directory %s does not exist", dir)
	}
	// Can just write an empty file to outPath so the binary "exists"
	err := os.WriteFile(outPath, nil, 0o644)
	if err != nil {
		return errors.Wrapf(err, "failed to write build to %s", outPath)
	}
	return nil
}

func (mg *mockGo) GetD(ctx context.Context, mod, dir string) error {
	t, err := tool.ParseLax(mod)
	if err != nil {
		return err
	}

	m, ok := mg.registry[t.ImportPath]
	if !ok {
		return errors.Errorf("unknown package %s", mod)
	}

	modver := module.Version{Path: m.name}
	if t.Version == "" || t.Version == "latest" {
		modver.Version = m.versions[len(m.versions)-1]
	} else {
		// If version is provided, see if it exists
		found := false
		// TODO(@cszatmary): Make this work with shorthand semvers
		if t.HasSemver() {
			for _, v := range m.versions {
				if v == t.Version {
					modver.Version = v
					found = true
					break
				}
			}
		} else {
			// If no semver, see if a matching query exists
			for q, v := range m.queries {
				if q == t.Version {
					modver.Version = v
					found = true
					break
				}
			}
		}
		if !found {
			return errors.Errorf("module %s has no version %s", t.ImportPath, t.Version)
		}
	}

	modfilePath := filepath.Join(dir, "go.mod")
	data, err := os.ReadFile(modfilePath)
	if os.IsNotExist(err) {
		// Treat no go.mod as an error because it is required for shed to work properly.
		// If there is no go.mod then go get will function in non-module mode which we don't want.
		return errors.Errorf("failed to download %s, no go.mod file found at %s", mod, dir)
	} else if err != nil {
		return errors.Wrapf(err, "failed to read %s", modfilePath)
	}

	modFile, err := modfile.Parse(modfilePath, data, nil)
	if err != nil {
		return errors.Wrapf(err, "failed to parse go.mod file %s", modfilePath)
	}

	// Add resolved module to go.mod
	modFile.AddNewRequire(modver.Path, modver.Version, true)
	newData, err := modFile.Format()
	if err != nil {
		return errors.Wrapf(err, "failed to update modfile %s", modfilePath)
	}
	err = os.WriteFile(modfilePath, newData, 0o644)
	if err != nil {
		return errors.Wrapf(err, "failed to write modfile %s", modfilePath)
	}
	return nil
}

func (mg mockGo) ListU(ctx context.Context, mod, dir string) (GoModule, error) {
	var gm GoModule
	modfilePath := filepath.Join(dir, "go.mod")
	data, err := os.ReadFile(modfilePath)
	if os.IsNotExist(err) {
		// Treat no go.mod as an error because it is required for shed to work properly.
		return gm, errors.Errorf("no go.mod file found at %s", dir)
	} else if err != nil {
		return gm, errors.Wrapf(err, "failed to read %s", modfilePath)
	}

	modFile, err := modfile.Parse(modfilePath, data, nil)
	if err != nil {
		return gm, errors.Wrapf(err, "failed to parse go.mod file %s", modfilePath)
	}
	if len(modFile.Require) != 1 {
		return gm, errors.Errorf("expected 1 dependency in modfile at %s but found %d", dir, len(modFile.Require))
	}

	r := modFile.Require[0]
	if r.Mod.Path != mod {
		return gm, errors.Errorf("module %s is not a known dependency", mod)
	}
	// Find the matching module, can't do fast lookup since we don't have the tool import path
	var latest string
	found := false
	for _, m := range mg.registry {
		if m.name == r.Mod.Path {
			latest = m.versions[len(m.versions)-1]
			found = true
			break
		}
	}
	if !found {
		return gm, errors.Errorf("unknown module %s", r.Mod.Path)
	}

	gm.Path = r.Mod.Path
	gm.Version = r.Mod.Version
	if latest != r.Mod.Version {
		gm.Update = &GoModule{Path: r.Mod.Path, Version: latest}
	}
	return gm, nil
}
